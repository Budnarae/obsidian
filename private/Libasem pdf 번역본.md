
---

#42Seoul #language/asm #translation

_assembly library_

---

# Libasm

**Assembly yourself!**

**요약**: 이 프로젝트의 목표는 어셈블리 언어에 익숙해지는 것입니다.

**버전**: 5

---

## 목차

다음 표:

- **I. 서론**
- **II. 공통 지침**
- **III. 필수 파트**
- **IV. 보너스 파트**
- **V. 제출 및 동료 평가**

---

## 챕터 I: 서론

어셈블리 (또는 어셈블러) 언어는 종종 asm으로 축약되는데, 이는 컴퓨터 또는 다른 프로그래밍 가능한 장치를 위한 저수준 프로그래밍 언어이며, 언어와 아키텍처의 기계어 명령어 사이에 매우 강한 (하지만 종종 일대일은 아닌) 대응 관계를 가집니다. 각 어셈블리 언어는 특정 컴퓨터 아키텍처에 고유합니다. 이와 대조적으로, 대부분의 고수준 프로그래밍 언어는 일반적으로 여러 아키텍처에서 이식 가능하지만 해석 또는 컴파일이 필요합니다. 어셈블리 언어는 또한 기호 기계어라고도 불릴 수 있습니다.

---

## 챕터 II: 공통 지침

- 함수는 미정의 동작을 제외하고 예상치 못하게 종료되어서는 안 됩니다 (세그멘테이션 오류, 버스 오류, 이중 해제 등). 이런 일이 발생하면, 프로젝트는 작동하지 않는 것으로 간주되어 평가 시 0점을 받게 됩니다.
    
- Makefile은 최소한 `$(NAME)`, `all`, `clean`, `fclean`, `re` 규칙을 포함해야 합니다. 그리고 필요한 파일만 재컴파일/재링크해야 합니다.
    
- 프로젝트에 보너스를 제출하려면 Makefile에 `bonus` 규칙을 포함해야 하며, 이는 프로젝트의 주요 부분에서 금지된 모든 다양한 헤더, 라이브러리 또는 함수를 추가할 것입니다. 보너스는 다른 `file_bonus.${\{c/h}}$`에 있어야 합니다. 필수 및 보너스 부분 평가는 별도로 진행됩니다.
    
- 이 작업은 제출하거나 채점되지 않지만, 프로젝트를 위한 테스트 프로그램을 만들 것을 권장합니다. 이는 자신의 작업과 동료의 작업을 쉽게 테스트할 기회를 제공할 것입니다. 이러한 테스트는 특히 방어 중에 유용할 것입니다. 실제로, 방어 중에는 자신의 테스트 및/또는 평가하는 동료의 테스트를 자유롭게 사용할 수 있습니다.
    
- 할당된 git 저장소에 작업을 제출해야 합니다. git 저장소에 있는 작업만 채점될 것입니다. Deepthought가 작업을 채점하도록 할당된 경우, 동료 평가 후에 진행될 것입니다. Deepthought가 채점하는 동안 작업의 어떤 섹션에서든 오류가 발생하면 평가가 중단될 것입니다.
    
- 64비트 ASM을 작성해야 합니다. "호출 규약"에 유의해야 합니다.
    
- 인라인 ASM을 사용할 수 없으며, 's' 파일을 만들어야 합니다.
    
- 어셈블리 코드를 `nasm`으로 컴파일해야 합니다.
    
- AT&T 구문이 아닌 Intel 구문을 사용해야 합니다.
    
- 컴파일 플래그: `-no-pie` 사용은 금지됩니다.
    

---

## 챕터 III: 필수 파트

- 라이브러리 이름은 `libasm.a`여야 합니다.
    
- 함수를 테스트하고 기능성을 보여주기 위해 라이브러리와 함께 컴파일될 `main`을 제출해야 합니다.
    
- 다음 함수를 asm으로 다시 작성해야 합니다:
    
    - `ft_strlen` (man 3 strlen)
        
    - `ft_strcpy` (man 3 strcpy)
        
    - `ft_strcmp` (man 3 strcmp)
        
    - `ft_write` (man 2 write)
        
    - `ft_read` (man 2 read)
        
    - `ft_strdup` (man 3 strdup, `malloc` 호출 가능)
        
- syscall 중에 오류를 확인하고 필요할 때 올바르게 설정해야 합니다.
    
- 코드는 `errno` 변수를 올바르게 설정해야 합니다.
    
- 이를 위해 외부 `error` 또는 `errno` 위치를 호출할 수 있습니다.
    

---

## 챕터 IV: 보너스 파트

이러한 함수를 asm으로 다시 작성할 수 있습니다. 연결 리스트 함수는 다음 구조를 사용할 것입니다:

C

```
typedef struct s_list
{
    void *data;
    struct s_list *next;
} t_list;
```

- `ft_atoi_base` (피신에 있는 것과 유사)
    
- `ft_list_push_front` (피신에 있는 것과 유사)
    
- `ft_list_size` (피신에 있는 것과 유사)
    
- `ft_list_sort` (피신에 있는 것과 유사)
    
- `ft_list_remove_if` (피신에 있는 것과 유사)
    

**보너스 부분은 필수 부분이 완벽할 경우에만 평가될 것입니다.** 완벽하다는 것은 필수 부분이 완전히 완료되었고 오작동 없이 작동한다는 의미입니다. 모든 필수 요구 사항을 통과하지 못하면 보너스 부분은 전혀 평가되지 않을 것입니다.

---

## 챕터 V: 제출 및 동료 평가

평소와 같이 Git 저장소에 과제를 제출해야 합니다. 방어 중에는 저장소 내의 작업만 평가될 것입니다. 폴더 및 파일 이름이 올바른지 다시 확인하는 것을 주저하지 마세요.
