---
tags:
  - graphics
  - translation
---

---

[원문](https://www-sop.inria.fr/reves/Basilic/2002/SD02/PerspectiveShadowMaps.pdf)

---


# Perspective Shadow Maps

**Marc Stamminger and George Drettakis**  
**REVES - INRIA Sophia-Antipolis, France**  
http://www-sop.inria.fr/reves/

**[그림 1]** (왼쪽) 균일한 512x512 그림자 맵과 결과 이미지. (오른쪽) 동일한 크기의 원근 그림자 맵을 사용한 결과.

## 초록

그림자 맵은 잘 알려진 엘리어싱 문제에도 불구하고 아마도 그림자 생성에 가장 널리 사용되는 수단일 것입니다. 이 논문에서 우리는 정규화된 장치 좌표 공간(normalized device coordinate space), 즉 원근 변환 후에 생성되는 원근 그림자 맵을 소개합니다. 이는 거의 오버헤드 없이 그림자 맵 엘리어싱을 중요하게 감소시킵니다. 우리는 광원 변환을 올바르게 처리하고 그림자를 드리우는 모든 객체를 변환된 공간에 포함하는 방법을 보여줍니다. 원근 그림자 맵은 인터랙티브 하드웨어 가속 렌더링뿐만 아니라 고품질 오프라인 렌더러에서도 표준 그림자 맵을 직접 대체할 수 있습니다.

**CR 카테고리:** I.3.3 [컴퓨터 그래픽스]: 그림/이미지 생성—비트맵 및 프레임버퍼 연산; I.3.7 [컴퓨터 그래픽스]: 3차원 그래픽스 및 리얼리즘—색상, 셰이딩, 그림자, 텍스처

**키워드:** 프레임 버퍼 알고리즘, 그래픽스 하드웨어, 조명, 레벨 오브 디테일 알고리즘, 렌더링, 그림자 알고리즘

## 1. 서론

그림자는 모든 컴퓨터 그래픽스 이미지에서 중요한 요소입니다. 그림자는 사용자가 장면의 공간적 관계를 이해하는 데 도움이 되는 중요한 시각적 단서를 제공하고 합성 이미지에 사실감을 더합니다. 그림자 생성의 과제는 컴퓨터 그래픽스 초기로 거슬러 올라가며, 클리핑[15] 또는 그림자 볼륨[1]을 기반으로 하는 다양한 기하학적 알고리즘이 도입되었습니다. 이러한 방법들은 필요한 기하학적 계산으로 인해 견고성 문제를 겪는 경우가 많으며, 복잡한 데이터 구조를 필요로 하거나 상당한 렌더링 오버헤드를 수반할 수 있습니다. 또한, 이러한 알고리즘은 일반적으로 전처리 단계이므로 정적 장면에 가장 적합합니다.

그림자 맵[16]의 도입은 그림자 알고리즘 진화의 중요한 단계를 의미했습니다. 그림자 맵을 사용하면 광원의 관점에서 장면을 렌더링하여 깊이 이미지를 생성합니다. 최종 이미지의 각 픽셀을 렌더링할 때, 보이는 점은 조명 좌표계로 변환되고 해당 그림자 맵 픽셀과 깊이 비교가 수행되어 그 점이 광원에 대해 숨겨져 있는지 결정합니다. 단일 그림자 맵은 방향성 조명과 스포트 라이트에 충분합니다. 전방향 점 광원은 모든 방출 방향을 커버하기 위해 여러 그림자 맵이 필요합니다. 이 논문에서 점 광원을 고려할 때, 우리는 암묵적으로 스포트 라이트를 의미하지만, 여기서 개발된 아이디어는 전방향 점 광원으로 쉽게 전환됩니다.

견고성 문제가 있는 기하학적 계산을 필요로 하는 그림자 알고리즘과 비교하여, 그림자 맵은 훨씬 더 일반적입니다. 단순성 때문에 그림자 맵은 그래픽스 하드웨어에 통합되었으며, 처음에는 Infinite Reality[6]에서, 그리고 최근에는 NVIDIA GeForce3와 같은 소비자급 그래픽 카드에서 통합되었습니다. 대규모 장면에 대한 그림자를 가질 수 있는 가능성은 비디오 게임과 같은 렌더링 집약적 애플리케이션에 그림자 맵을 특히 흥미롭게 만듭니다. 그림자 맵은 단순성과 유연성 때문에 오프라인 고품질 렌더링 시스템에서도 널리 사용됩니다. 예를 들어, RenderMan 표준에서 그림자 맵은 그림자가 있는 이미지를 생성하는 가장 널리 사용되는 방법입니다[13].

그러나 이산 버퍼를 기반으로 하는 모든 방법과 마찬가지로, 렌더링되는 이미지에 사용되는 그림자 맵 해상도가 불충분한 경우 그림자 맵은 엘리어싱 문제를 겪습니다. 이는 특히 넓은 깊이 범위를 가진 장면에서 사실입니다. 가까운 그림자는 높은 해상도가 필요하지만 먼 그림자는 낮은 해상도로 충분합니다. 최근의 그림자 맵 접근법[12, 2]은 다양한 해상도의 여러 그림자 맵을 사용하여 그림자 맵 해상도를 조정합니다. 그러나 여러 그림자 맵을 사용함으로써 여러 렌더링 패스가 필요하고, 더 복잡한 데이터 구조로 인해 이 방법들은 더 이상 하드웨어에 매핑되지 않습니다.

이 논문에서 우리는 현재 뷰에 그림자 맵 해상도를 조정하는 새로운 접근법을 제시합니다. 비균일 파라미터화를 사용하여 단일 원근 그림자 맵이 생성되어 가까운 객체에 대해 높은 해상도를 제공하고 시점에서 멀어질수록 감소된 해상도를 제공합니다. 예시는 그림 1에 나와 있습니다. 표준 그림자 맵(왼쪽)은 가까운 객체에 대해 불충분한 해상도를 가집니다(중앙 왼쪽). 대조적으로, 우리의 원근 그림자 맵(중앙 오른쪽)에서는 해상도가 달라져서 가까운 객체가 충분한 그림자 맵 해상도를 갖습니다(오른쪽).

우리의 그림자 맵 투영은 여전히 4×4 행렬로 표현될 수 있으므로 하드웨어에 완전히 매핑됩니다. 최적화된 투영 행렬 계산에 대한 약간의 오버헤드만으로 그림자 맵을 기반으로 하는 모든 인터랙티브 및 오프라인 렌더링 방법을 개선하는 데 쉽게 사용할 수 있습니다. 원근 그림자 맵은 종종 엘리어싱을 극적으로 감소시킵니다. 몇 가지 어려운 경우에, 우리의 파라미터화는 표준 균일 그림자 맵으로 수렴합니다. 우리의 접근법은 뷰 종속적이므로 각 프레임마다 또는 적어도 주요 카메라 이동 후에 새로운 그림자 맵 생성이 필요합니다. 이것은 어쨌든 비디오 게임이나 다른 인터랙티브 애플리케이션에서 사용되는 것과 같이 움직이는 객체를 포함하는 장면에 필요합니다. 이 경우, 표준 고정 해상도 그림자 맵과 비교하여 속도 저하가 크지 않습니다.

## 1.1 그림자 맵 엘리어싱

먼저, 점 광원에 대한 그림자 맵의 엘리어싱 문제를 간단히 공식화합니다. 그림자 맵의 모든 픽셀은 (그림자) 이미지 평면에서 크기가 ds × ds인 그림자 맵 픽셀을 통과하는 전단된 광선 피라미드를 나타냅니다(그림 2). 다음에서 우리는 ds의 역수를 그림자 맵 해상도라고 부를 것입니다. 그림자 맵 해상도를 높이기 위해 ds를 감소시키고 그 반대도 마찬가지입니다. 그림자 맵 픽셀을 통과하는 광선 묶음이 각도 α로 거리 rs에서 표면과 충돌할 때, 교차점의 크기는 대략 ds·rs/cosα입니다. 최종 이미지에서 이 표면과의 교차점의 크기는 다음과 같습니다:

d = ds · (rs/ri) · (cosβ/cosα)

여기서 β는 광원 방향과 표면 법선 사이의 각도이고 ri는 카메라에서 교차점까지의 거리입니다.

**[그림 2]** 그림자 맵 투영 변수들.

방향성 광원의 경우, d는 rs에 독립적이므로 d는 ds/ri에만 의존합니다. 유사하게, 직교 뷰의 경우 d는 ds·rs에 비례합니다.

그림자 맵 언더샘플링은 d가 이미지 픽셀 크기 di보다 클 때 나타납니다. 이는 ds·rs/ri가 커질 때 발생할 수 있으며, 일반적으로 사용자가 그림자 경계로 확대하여 단일 그림자 맵 픽셀이 보일 때 발생합니다. 우리는 이것을 **원근 엘리어싱(perspective aliasing)**이라고 부를 것입니다. 제한된 메모리로 인해 그림자 맵 해상도 1/ds는 실제로 특정 한계까지만 증가할 수 있습니다. 원근 엘리어싱은 분수 rs/ri를 상수에 가깝게 유지함으로써 피할 수 있습니다. 이 논문에서 보여주듯이, 이것이 원근 변환 후에 그림자 맵을 계산할 때 달성되는 것입니다.

cosβ/cosα가 커지면 **투영 엘리어싱(projection aliasing)**이 나타납니다. 이는 일반적으로 광선이 표면과 거의 평행할 때 발생하여 그림자가 표면을 따라 늘어납니다. 투영 엘리어싱은 원근 그림자 맵에서 처리되지 않습니다. 왜냐하면 이는 그림자 맵 해상도의 국소적 증가를 필요로 하기 때문입니다. 이것은 훨씬 더 복잡한 데이터 구조 없이는 불가능하며, 하드웨어 가속을 포기해야 합니다.

그림자 맵을 사용할 때는 다른 엘리어싱 소스도 있습니다. 예를 들어 깊이 양자화가 있지만, 여기서는 다루지 않습니다.

---

1.1절까지의 완전한 번역을 제공했습니다. 원문의 모든 내용을 누락 없이 번역했습니다.