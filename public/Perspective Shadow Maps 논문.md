---
tags:
  - graphics
  - translation
---

---

[원문](https://www-sop.inria.fr/reves/Basilic/2002/SD02/PerspectiveShadowMaps.pdf)

---


# Perspective Shadow Maps

**Marc Stamminger and George Drettakis**  
**REVES - INRIA Sophia-Antipolis, France**  
http://www-sop.inria.fr/reves/

**[그림 1]** (왼쪽) 균일한 512x512 그림자 맵과 결과 이미지. (오른쪽) 동일한 크기의 원근 그림자 맵을 사용한 결과.

## 초록

그림자 맵은 잘 알려진 엘리어싱 문제에도 불구하고 아마도 그림자 생성에 가장 널리 사용되는 수단일 것입니다. 이 논문에서 우리는 정규화된 장치 좌표 공간(normalized device coordinate space), 즉 원근 변환 후에 생성되는 원근 그림자 맵을 소개합니다. 이는 거의 오버헤드 없이 그림자 맵 엘리어싱을 중요하게 감소시킵니다. 우리는 광원 변환을 올바르게 처리하고 그림자를 드리우는 모든 객체를 변환된 공간에 포함하는 방법을 보여줍니다. 원근 그림자 맵은 인터랙티브 하드웨어 가속 렌더링뿐만 아니라 고품질 오프라인 렌더러에서도 표준 그림자 맵을 직접 대체할 수 있습니다.

**CR 카테고리:** I.3.3 [컴퓨터 그래픽스]: 그림/이미지 생성—비트맵 및 프레임버퍼 연산; I.3.7 [컴퓨터 그래픽스]: 3차원 그래픽스 및 리얼리즘—색상, 셰이딩, 그림자, 텍스처

**키워드:** 프레임 버퍼 알고리즘, 그래픽스 하드웨어, 조명, 레벨 오브 디테일 알고리즘, 렌더링, 그림자 알고리즘

## 1. 서론

그림자는 모든 컴퓨터 그래픽스 이미지에서 중요한 요소입니다. 그림자는 사용자가 장면의 공간적 관계를 이해하는 데 도움이 되는 중요한 시각적 단서를 제공하고 합성 이미지에 사실감을 더합니다. 그림자 생성의 과제는 컴퓨터 그래픽스 초기로 거슬러 올라가며, 클리핑[15] 또는 그림자 볼륨[1]을 기반으로 하는 다양한 기하학적 알고리즘이 도입되었습니다. 이러한 방법들은 필요한 기하학적 계산으로 인해 견고성 문제를 겪는 경우가 많으며, 복잡한 데이터 구조를 필요로 하거나 상당한 렌더링 오버헤드를 수반할 수 있습니다. 또한, 이러한 알고리즘은 일반적으로 전처리 단계이므로 정적 장면에 가장 적합합니다.

그림자 맵[16]의 도입은 그림자 알고리즘 진화의 중요한 단계를 의미했습니다. 그림자 맵을 사용하면 광원의 관점에서 장면을 렌더링하여 깊이 이미지를 생성합니다. 최종 이미지의 각 픽셀을 렌더링할 때, 보이는 점은 조명 좌표계로 변환되고 해당 그림자 맵 픽셀과 깊이 비교가 수행되어 그 점이 광원에 대해 숨겨져 있는지 결정합니다. 단일 그림자 맵은 방향성 조명과 스포트 라이트에 충분합니다. 전방향 점 광원은 모든 방출 방향을 커버하기 위해 여러 그림자 맵이 필요합니다. 이 논문에서 점 광원을 고려할 때, 우리는 암묵적으로 스포트 라이트를 의미하지만, 여기서 개발된 아이디어는 전방향 점 광원으로 쉽게 전환됩니다.

견고성 문제가 있는 기하학적 계산을 필요로 하는 그림자 알고리즘과 비교하여, 그림자 맵은 훨씬 더 일반적입니다. 단순성 때문에 그림자 맵은 그래픽스 하드웨어에 통합되었으며, 처음에는 Infinite Reality[6]에서, 그리고 최근에는 NVIDIA GeForce3와 같은 소비자급 그래픽 카드에서 통합되었습니다. 대규모 장면에 대한 그림자를 가질 수 있는 가능성은 비디오 게임과 같은 렌더링 집약적 애플리케이션에 그림자 맵을 특히 흥미롭게 만듭니다. 그림자 맵은 단순성과 유연성 때문에 오프라인 고품질 렌더링 시스템에서도 널리 사용됩니다. 예를 들어, RenderMan 표준에서 그림자 맵은 그림자가 있는 이미지를 생성하는 가장 널리 사용되는 방법입니다[13].

그러나 이산 버퍼를 기반으로 하는 모든 방법과 마찬가지로, 렌더링되는 이미지에 사용되는 그림자 맵 해상도가 불충분한 경우 그림자 맵은 엘리어싱 문제를 겪습니다. 이는 특히 넓은 깊이 범위를 가진 장면에서 사실입니다. 가까운 그림자는 높은 해상도가 필요하지만 먼 그림자는 낮은 해상도로 충분합니다. 최근의 그림자 맵 접근법[12, 2]은 다양한 해상도의 여러 그림자 맵을 사용하여 그림자 맵 해상도를 조정합니다. 그러나 여러 그림자 맵을 사용함으로써 여러 렌더링 패스가 필요하고, 더 복잡한 데이터 구조로 인해 이 방법들은 더 이상 하드웨어에 매핑되지 않습니다.

이 논문에서 우리는 현재 뷰에 그림자 맵 해상도를 조정하는 새로운 접근법을 제시합니다. 비균일 파라미터화를 사용하여 단일 원근 그림자 맵이 생성되어 가까운 객체에 대해 높은 해상도를 제공하고 시점에서 멀어질수록 감소된 해상도를 제공합니다. 예시는 그림 1에 나와 있습니다. 표준 그림자 맵(왼쪽)은 가까운 객체에 대해 불충분한 해상도를 가집니다(중앙 왼쪽). 대조적으로, 우리의 원근 그림자 맵(중앙 오른쪽)에서는 해상도가 달라져서 가까운 객체가 충분한 그림자 맵 해상도를 갖습니다(오른쪽).

우리의 그림자 맵 투영은 여전히 4×4 행렬로 표현될 수 있으므로 하드웨어에 완전히 매핑됩니다. 최적화된 투영 행렬 계산에 대한 약간의 오버헤드만으로 그림자 맵을 기반으로 하는 모든 인터랙티브 및 오프라인 렌더링 방법을 개선하는 데 쉽게 사용할 수 있습니다. 원근 그림자 맵은 종종 엘리어싱을 극적으로 감소시킵니다. 몇 가지 어려운 경우에, 우리의 파라미터화는 표준 균일 그림자 맵으로 수렴합니다. 우리의 접근법은 뷰 종속적이므로 각 프레임마다 또는 적어도 주요 카메라 이동 후에 새로운 그림자 맵 생성이 필요합니다. 이것은 어쨌든 비디오 게임이나 다른 인터랙티브 애플리케이션에서 사용되는 것과 같이 움직이는 객체를 포함하는 장면에 필요합니다. 이 경우, 표준 고정 해상도 그림자 맵과 비교하여 속도 저하가 크지 않습니다.

## 1.1 그림자 맵 엘리어싱

먼저, 점 광원에 대한 그림자 맵의 엘리어싱 문제를 간단히 공식화합니다. 그림자 맵의 모든 픽셀은 (그림자) 이미지 평면에서 크기가 ds × ds인 그림자 맵 픽셀을 통과하는 전단된 광선 피라미드를 나타냅니다(그림 2). 다음에서 우리는 ds의 역수를 그림자 맵 해상도라고 부를 것입니다. 그림자 맵 해상도를 높이기 위해 ds를 감소시키고 그 반대도 마찬가지입니다. 그림자 맵 픽셀을 통과하는 광선 묶음이 각도 α로 거리 rs에서 표면과 충돌할 때, 교차점의 크기는 대략 ds·rs/cosα입니다. 최종 이미지에서 이 표면과의 교차점의 크기는 다음과 같습니다:

d = ds · (rs/ri) · (cosβ/cosα)

여기서 β는 광원 방향과 표면 법선 사이의 각도이고 ri는 카메라에서 교차점까지의 거리입니다.

**[그림 2]** 그림자 맵 투영 변수들.

방향성 광원의 경우, d는 rs에 독립적이므로 d는 ds/ri에만 의존합니다. 유사하게, 직교 뷰의 경우 d는 ds·rs에 비례합니다.

그림자 맵 언더샘플링은 d가 이미지 픽셀 크기 di보다 클 때 나타납니다. 이는 ds·rs/ri가 커질 때 발생할 수 있으며, 일반적으로 사용자가 그림자 경계로 확대하여 단일 그림자 맵 픽셀이 보일 때 발생합니다. 우리는 이것을 **원근 엘리어싱(perspective aliasing)**이라고 부를 것입니다. 제한된 메모리로 인해 그림자 맵 해상도 1/ds는 실제로 특정 한계까지만 증가할 수 있습니다. 원근 엘리어싱은 분수 rs/ri를 상수에 가깝게 유지함으로써 피할 수 있습니다. 이 논문에서 보여주듯이, 이것이 원근 변환 후에 그림자 맵을 계산할 때 달성되는 것입니다.

cosβ/cosα가 커지면 **투영 엘리어싱(projection aliasing)**이 나타납니다. 이는 일반적으로 광선이 표면과 거의 평행할 때 발생하여 그림자가 표면을 따라 늘어납니다. 투영 엘리어싱은 원근 그림자 맵에서 처리되지 않습니다. 왜냐하면 이는 그림자 맵 해상도의 국소적 증가를 필요로 하기 때문입니다. 이것은 훨씬 더 복잡한 데이터 구조 없이는 불가능하며, 하드웨어 가속을 포기해야 합니다.

그림자 맵을 사용할 때는 다른 엘리어싱 소스도 있습니다. 예를 들어 깊이 양자화가 있지만, 여기서는 다루지 않습니다.

---

## 3. 후-원근 광원

우리의 새로운 방법을 적용하기 위해, 먼저 카메라 행렬을 사용하여 장면을 후-원근 공간으로 변환합니다. 그런 다음 동일한 행렬로 광원을 변환하고 그림자 맵을 생성합니다. 발생하는 다양한 경우는 다음에 설명됩니다.

### 3.1 방향성 광원

방향성 광원은 무한대에 있는 점 광원으로 간주될 수 있습니다. 원근 매핑은 이러한 광원을 유한한 위치로 이동시킬 수 있습니다. 가능한 경우의 집합은 그림 3과 4에 나와 있습니다. 이미지 평면에 평행한 방향성 광원은 무한대에 남아 있습니다. 다른 모든 방향성 광원은 z = (f + n)/(f - n)의 무한대 평면에서 점 광원이 됩니다. 여기서 n과 f는 시야 프러스텀의 근거리 및 원거리입니다(그림 3 참조).

앞쪽에서 비추는 방향성 광원은 후-원근 공간에서 점 광원이 되고(그림 4, 왼쪽), 뒤에서 오는 방향성 광원은 "반전된" 점 광원으로 매핑됩니다(중앙). 이 맥락에서 "반전된"이란 이러한 광원의 모든 광선이 방출되지 않고 단일 점으로 수렴한다는 것을 의미합니다. 이러한 반전된 점 광원은 그림자 맵 깊이 테스트를 역으로 하여 점 광원처럼 쉽게 처리할 수 있으므로, 점 광원에서 가장 먼 히트 포인트가 살아남습니다. 극단적인 경우는 뷰 방향에 평행한(정면 또는 반대) 방향성 조명이며, 이는 뷰어 바로 앞의 점 광원으로 매핑됩니다(오른쪽).

**[그림 4]** 월드 공간의 방향성 조명(위 행)은 후-원근 공간에서 무한대 평면의 점 광원이 됩니다(아래 행). 뒤에서 오는 조명은 반전됩니다. 즉, 광선을 따른 히트의 순서가 반전됩니다.

### 3.2 점 광원

점 광원에 대한 다양한 설정은 그림 5에 나와 있습니다. 뷰어 앞의 점 광원은 점 광원으로 남아 있습니다(왼쪽). 뷰어 뒤의 점 광원은 무한대 평면 너머로 매핑되어 반전됩니다(중앙). 그러나 뷰 방향에 수직인 뷰 포인트를 통과하는 평면(카메라 평면)의 점 광원은 방향성이 됩니다(오른쪽).

**[그림 5]** 월드 공간의 점 광원(위 행)을 후-원근 공간으로 매핑(아래 행). 사용자 앞의 점 광원은 일반 점 광원으로 남아 있고(왼쪽), 뷰어 뒤의 점 광원은 반전됩니다(중앙). 경계 경우는 방향성 조명으로 매핑됩니다(오른쪽).

### 3.3 논의

후-원근 공간에서 최종 이미지는 단위 큐브에 대한 직교 뷰입니다. 섹션 1.1의 관찰을 따르면, 이것은 눈까지의 거리 ri로 인한 원근 엘리어싱이 피해진다는 것을 의미합니다. 그러나 광원이 후-원근 공간에서 점 광원으로 매핑되면, 그림자 맵 이미지 평면까지의 거리 rs로 인한 엘리어싱이 나타날 수 있습니다.

이상적인 경우는 원근 매핑 후에 광원이 방향성일 때 발생합니다. 따라서 rs로 인한 원근 엘리어싱도 피해집니다. 이것은 다음의 경우에 발생합니다:

• 이미지 평면에 평행한 방향성 조명(그림 3 참조)
• 카메라 평면의 점 광원. 전형적인 예는 광부의 헤드램프, 즉 카메라 바로 위의 점 광원입니다.

이 설정이 표준 그림자 맵에 대해서도 이상적이라는 것이 알려져 있습니다[7]. 우리의 파라미터화를 사용하면, 점이 카메라 평면에 남아 있는 한 오프셋은 임의로 클 수 있습니다.

반면에, 후-원근 공간에서 큰 깊이 범위를 가진 점 광원을 얻을 때 덜 최적화된 경우가 나타납니다. 극단적인 예는 뷰 방향에 평행한 방향성 조명입니다. 후-원근 공간에서 이것은 뷰어의 반대편 무한대 평면의 점 광원이 됩니다(그림 4 오른쪽 참조). 이 최악의 경우 반대 뷰 방향을 가진 두 원근 투영이 서로 상쇄되고 표준 균일 그림자 맵을 얻습니다.

일반적으로, 방향성 광원의 경우 이점은 뷰 방향에 수직인 조명 방향에 대해 최대입니다. 이들은 후-원근 공간에서도 평행 조명이기 때문에, 이 경우 원근 엘리어싱이 완전히 피해집니다. 조명 방향과 뷰 방향 사이에 형성된 두 각도 중 작은 각도를 고려하십시오. 이 각도가 작아질수록 우리 접근법의 이점은 감소합니다. 왜냐하면 이상적인 수직 경우에서 더 멀어지기 때문입니다. 각도가 0이면 우리의 파라미터화는 균일 그림자 맵에 해당합니다.

점 광원의 경우, 분석이 더 어렵습니다. 왜냐하면 점 광원도 원근 투영을 적용하기 때문입니다. 비공식적으로, 점 광원이 시야 프러스텀에서 멀리 떨어져 있어서 평행 조명과 유사하고, 보이는 조명된 영역이 큰 깊이 범위를 나타낼 때 우리의 파라미터화의 장점이 가장 큽니다. 균일 그림자 맵에 대해 이상적이라고 알려진 광부의 램프의 경우[7], 우리의 파라미터화는 다시 균일 설정으로 수렴합니다.

그림자 맵의 일반적인 문제는 자기 가림(self-occlusion) 또는 표면 여드름(surface acne)을 피하기 위해 필요한 바이어스입니다[7]. 이 문제는 객체가 비균일하게 스케일되기 때문에 원근 그림자 맵에 대해 증가합니다. 우리는 그림자 맵 공간의 깊이에서 상수 오프셋을 사용하며, 이는 장면에 따라 사용자 조정이 필요할 수 있습니다.

---

## 4. 그림자를 드리우는 모든 객체 포함하기

지금까지 우리는 중요한 문제를 무시했습니다: 우리의 그림자 맵은 현재 시야 프러스텀에 최적화되어 있습니다. 그러나 그림자 맵은 그 프러스텀 내의 모든 객체와 가시적인 객체에 그림자를 드리울 수 있는 프러스텀 외부의 모든 잠재적 차폐물을 포함해야 합니다.

### 4.1 월드 공간

더 공식적으로, 그림자 맵에 나타나야 하는 점들의 집합을 다음과 같이 정의합니다: S를 장면 객체의 엔벨로프(envelope), 일반적으로 바운딩 박스라고 하겠습니다. V는 시야 프러스텀이고 L은 광원 프러스텀입니다. 광원은 위치 l에 있습니다(방향성 조명의 경우 L = R³이고 l은 무한대에 있습니다). 먼저, V와 l의 볼록 껍질(convex hull) M을 계산하므로, M은 V의 점들에서 l로 가는 모든 광선을 포함합니다. 그런 다음 M에서 장면의 바운딩 박스와 조명 프러스텀 외부의 모든 점들을 제거합니다: H = M ∩ S ∩ L (그림 6의 오른쪽에 노란색으로 표시됨).

**[그림 6]** 현재 뷰 프러스텀 V, 광원 위치 l을 가진 조명 프러스텀 L, 그리고 장면 바운딩 박스 S (왼쪽). M은 V를 조명을 향해 확장하여 얻어집니다(중앙). 그런 다음 M은 S 및 L과 교차되어 그림자 맵에서 보여야 하는 점들의 집합을 얻습니다(오른쪽).

우리의 구현에서 우리는 이러한 기하학적 계산을 수행하기 위해 계산 기하학 라이브러리 CGAL(www.cgal.org)을 사용합니다. 결과적으로, 그림자 맵의 윈도우는 H의 모든 점이 포함되도록 선택됩니다. 그러나 그림자 맵은 H가 아닌 후-원근 공간으로의 변환을 볼 것이므로, 원근 매핑에 의해 H가 어떻게 변하는지 고려해야 합니다.

### 4.2 후-원근 공간

투영 변환 하에서 직선은 직선으로 남지만, 직선을 따른 점들의 순서는 바뀔 수 있습니다. 원근 투영의 경우, 이것은 직선이 카메라 평면과 교차할 때 발생하며, 교차점은 무한대로 매핑됩니다. 결과적으로, H가 완전히 뷰어 앞에 있는 한, H의 정점들을 변환함으로써 볼록 집합 H를 후-원근 공간으로 빠르게 변환할 수 있습니다. 그렇지 않은 경우의 예는 그림 7에 나와 있습니다. 뷰어 뒤의 점들은 시야 프러스텀에 그림자를 드리울 수 있기 때문에 포함되어야 했습니다. 그러나 후-원근 공간에서 이러한 점들은 무한대 평면 너머로 투영됩니다. 이 경우, 가능한 차폐물은 무한대 평면의 양쪽에 있을 수 있습니다.

**[그림 7]** 장면은 뒤에서 오는 방향성 광원에 의해 조명됩니다(위 왼쪽). 원근 투영 후, 뷰어 뒤의 객체는 반전되어 무한대 평면의 반대편에 나타납니다(아래 왼쪽). 이를 처리하기 위해 우리는 투영 중심을 뒤로 이동시켜(위 오른쪽), 뷰 프러스텀에 그림자를 드리울 수 있는 가장 먼 점 뒤에 있도록 합니다. 이후에는 후-원근 공간의 표준 그림자 맵이 다시 충분합니다(아래 오른쪽).

한 가지 해결책은 이 경우 두 개의 그림자 맵을 생성하는 것입니다. 앞서 설명한 것과 같은 첫 번째 것과, 무한대 평면 "너머"를 보는 두 번째 것입니다. 우리는 가상 카메라 이동으로 이 어색한 해결책을 피합니다. 우리는 H가 변환된 카메라 프러스텀 내에 완전히 놓이도록 카메라 뷰 포인트를 가상으로 뒤로 이동시킵니다. 근평면 거리는 변하지 않고 원평면 거리는 이전의 전체 프러스텀을 포함하도록 증가됩니다. 이 카메라 포인트 변위는 그림자 맵 생성에만 해당되며, 이미지 렌더링에는 해당되지 않습니다.

이를 통해 우리는 후-원근 공간을 수정하여 원근 단축(perspective foreshortening)을 감소시킵니다. 카메라를 무한대로 이동하면, 원래 월드 공간과 동등한 후-원근 공간을 가진 직교 뷰를 얻습니다. 결과적인 원근 그림자 맵은 표준 균일 그림자 맵에 해당합니다. 결과적으로, 카메라를 뒤로 이동시킴으로써 우리의 파라미터화는 표준 그림자 맵의 것으로 저하된다고 말할 수 있습니다.

이를 통해 원근 엘리어싱이 다시 도입되지만, 실제로 이것은 극단적인 경우에만 관련이 있으므로, 우리는 이것이 이중 그림자 맵 해결책보다 바람직하다는 것을 발견했습니다. 원근 그림자 맵에 이상적인 경우에는 H가 항상 카메라 앞에 완전히 있기 때문에 그러한 이동이 필요하지 않다는 점이 흥미롭습니다. 이동 거리는 광원이 뷰어 훨씬 뒤에 있을 때만 중요합니다. 그러나 이 경우, 우리의 파라미터화는 어쨌든 균일 그림자 맵으로 수렴합니다.

---

## 5. 점 렌더링

점 렌더링(예: [8, 10, 11, 14])은 복잡한 기하학을 렌더링하는 매우 효과적인 수단임이 입증되었습니다. 점은 특히 자연 객체에 적합합니다. 그러나 균일 그림자 맵의 생성에서는 점 렌더링이 대부분의 이점을 잃습니다. 고해상도 균일 그림자 맵을 렌더링하기 위해서는 매우 크고 조밀한 점 집합을 생성해야 합니다. 동적 장면에 대한 그림자 맵의 빈번한 재생성은 매우 비효율적이 됩니다.

반면에, 우리의 투영 그림자 맵 파라미터화는 [14, 11]에서 제시된 점 렌더링 접근법과 잘 맞습니다. 이러한 방법으로 생성된 점 집합이 그림자 맵의 렌더링에도 사용될 수 있다는 점에서 그렇습니다. 그 이유는 이러한 접근법들이 뷰어까지의 거리에 적응된 점 밀도를 가진 랜덤 점 클라우드를 생성하기 때문입니다. 후-원근 공간에서 이러한 점 클라우드는 균일한 점 밀도를 가집니다. 원근 그림자 맵이 이 공간에서 렌더링되므로, 그림자 맵은 점 밀도가 균일하다고 가정할 수 있습니다. 따라서 구멍을 피하도록 그림자 맵을 렌더링할 때 스플랫 크기를 선택하기가 쉽습니다.

## 6. 구현 및 결과

우리는 OpenGL 하드웨어 보조 그림자 맵을 사용하는 인터랙티브 렌더링 애플리케이션 내에서 원근 그림자 맵을 구현했습니다. 다음 결과들과 함께 제공되는 비디오의 모든 시퀀스는 두 개의 1 GHz Pentium III 프로세서와 NVIDIA GeForce3 그래픽 가속기를 갖춘 Compaq AP550에서 Linux로 얻어졌습니다. 우리는 그림자 맵 확장 GL_SGIX_depth_texture 및 GL_SGIX_shadow를 사용했습니다. 그림자 맵은 p-버퍼(GLX_SGIX_pbuffer)로 렌더링되고 레지스터 콤바이너(GL_NV_register_combiners)를 사용하여 적용됩니다.

원근 그림자 맵에서 최적의 결과를 얻기 위해, 우리는 뷰의 근평면이 가능한 한 멀리 있어야 합니다. 우리는 각 프레임 후에 깊이 버퍼를 다시 읽어들이고, 최소 깊이 값을 찾고, 그에 따라 근평면을 조정함으로써 이를 달성합니다. 우리 컴퓨터의 빠른 버스와 RAM으로 인해, 깊이 버퍼를 다시 읽는 속도 저하는 보통입니다. 예를 들어, 640 x 480 픽셀 해상도에서 16비트 정밀도로 깊이를 다시 읽는 데 10ms가 걸립니다. 품질의 향상은 이 오버헤드를 충분히 보상합니다.

그림 1은 스포트 라이트 광원에 의해 조명된 체스 보드 장면을 보여줍니다. 왼쪽 이미지는 균일 그림자 맵을 보여주고, 중앙 왼쪽 이미지는 명백히 보이는 그림자 맵 엘리어싱이 있는 결과 렌더링입니다. 오른쪽 끝 이미지는 동일한 크기의 원근 그림자 맵으로 얻었으며, 중앙 오른쪽에 표시됩니다.

그림 8은 군중과 나무로 보강된 파리의 노트르담을 보여줍니다. 나무와 군중에 대한 점 기반 렌더링을 사용하면, 표시된 뷰는 여전히 약 15 프레임/초로 얻어집니다.

그림 9의 거리 장면에서 자동차와 두 대의 비행기가 움직이고 있습니다. 그림은 인터랙티브 세션의 세 장면을 보여줍니다. 모든 이미지는 1024 × 1024 크기의 원근 그림자 맵으로 초당 10 프레임 이상으로 얻어졌습니다.

우리의 마지막 테스트 장면은 수백 개의 서로 다른 식물과 몇 마리의 소로 구성된 완전한 생태계입니다. 그림 10에 표시된 뷰는 2천만 개 이상의 삼각형을 포함합니다. 우리는 그림자가 없는 이미지(왼쪽), 1024 × 1024 균일 그림자 맵의 그림자가 있는 이미지(중앙), 그리고 동일한 크기의 투영 그림자 맵의 그림자가 있는 이미지(오른쪽)를 보여줍니다.

## 7. 결론

우리는 그림자 맵을 위한 새로운 파라미터화인 원근 그림자 맵을 도입했습니다. 우리의 접근법은 표준 균일 그림자 맵과 비교하여 크게 향상된 품질의 그림자 맵 생성을 가능하게 합니다. 적절한 투영 매핑을 선택함으로써, 그림자 맵 해상도가 적절한 곳에 집중됩니다. 우리는 또한 우리의 방법이 점 렌더링에 어떻게 사용될 수 있는지 보여주어, 고품질 그림자가 있는 매우 복잡한 장면의 인터랙티브 디스플레이를 가능하게 합니다. 원근 그림자 맵은 인터랙티브 애플리케이션에서 사용될 수 있으며 최신 그래픽스 하드웨어의 그림자 맵 기능을 완전히 활용하지만, 고품질 소프트웨어 렌더러에도 적용 가능합니다.

## 8. 감사의 말

첫 번째 저자는 이 작업을 수행하는 동안 Marie-Curie 박사후 펠로우십의 지원을 받았습니다. L. Kettner는 CGAL(www.cgal.org)에서 프러스텀 교차 코드를 구현했습니다. 매우 유익한 의견을 주신 F. Durand에게 감사드립니다. 결과 섹션의 대부분의 모델은 www.3dcafe.com 및 www.help3d.com에서 다운로드되었습니다.

## 참고문헌

[1] F. C. Crow. Shadow algorithms for computer graphics. Computer Graphics (Proc. of SIGGRAPH 77), 11(2):242–248, 1977.

[2] R. Fernando, S. Fernandez, K. Bala, and D. P. Greenberg. Adaptive shadow maps. Proc. of SIGGRAPH 2001, pages 387–390, 2001.

[3] J. D. Foley, A. van Dam, S. K. Feiner, and J. F. Hughes. Computer graphics, principles and practice, second edition. 1990.

[4] P. Heckbert. Survey of Texture Mapping. IEEE Computer Graphics and Applications, 6(11):56–67, November 1986.

[5] T. Lokovic and E. Veach. Deep shadow maps. Proc. of SIGGRAPH 2000, pages 385–392, 2000.

[6] J. S. Montrym, D. R. Baum, D. L. Dignam, and C. J. Migdal. Infinitereality: A real-time graphics system. Proc. of SIGGRAPH 97, pages 293–302, 1997.

[7] nvidia. webpage. http://developer.nvidia.com/view.asp?IO=cedec_shadowmap.

[8] H. Pfister, M. Zwicker, J. van Baar, and M. Gross. Surfels: Surface elements as rendering primitives. Proc. of SIGGRAPH 2000, pages 335–342, 2000.

[9] W. T. Reeves, D. H. Salesin, and R. L. Cook. Rendering antialiased shadows with depth maps. Computer Graphics (Proc. of SIGGRAPH 87), 21(4):283–291, 1987.

[10] S. Rusinkiewicz and M. Levoy. Qsplat: A multiresolution point rendering system for large meshes. Proc. of SIGGRAPH 2000, pages 343–352, 2000.

[11] M. Stamminger and G. Drettakis. Interactive sampling and rendering for complex and procedural geometry. In S. Gortler and K. Myszkowski, editors, Rendering Techniques 2001 (12th Eurographics Workshop on Rendering), pages 151–162. Springer Verlag, 2001.

[12] K. Tadamura, X. Qin, G. Jiao, and E. Nakamae. Rendering optimal solar shadows with plural sunlight depth buffers. The Visual Computer, 17(2):76–90, 2001.

[13] S. Upstill. The RenderMan Companion. Addison-Wesley, 1990.

[14] M. Wand, M. Fischer, I. Peter, F. Meyer auf der Heide, and W. Straßer. The randomized z-buffer algorithm: Interactive rendering of highly complex scenes. Proc. of SIGGRAPH 2001, pages 361–370, 2001.

[15] K. Weiler and K. Atherton. Hidden surface removal using polygon area sorting. Computer Graphics (Proc. of SIGGRAPH 77), 11(2):214–222, 1977.

[16] L. Williams. Casting curved shadows on curved surfaces. Computer Graphics (Proc. of SIGGRAPH 78), 12(3):270–274, 1978.

[17] A. Woo, P. Poulin, and A. Fournier. A survey of shadow algorithms. IEEE Computer Graphics and Applications, 10(6):13–32, November 1990.

---

**[그림 8]** 1024 × 1024 크기의 그림자 맵으로 렌더링된 노트르담. 왼쪽 이미지와 중앙 및 오른쪽 이미지의 오른쪽 반쪽은 약 15 프레임/초로 원근 그림자 맵으로 렌더링되었습니다. 중앙 및 오른쪽 이미지의 왼쪽 부분은 동일한 크기의 균일 그림자 맵으로 생성되었습니다. 나무와 군중의 렌더링은 점 렌더링으로 가속됩니다.

**[그림 9]** 움직이는 자동차와 비행기가 있는 거리 장면. 이미지는 1024 × 1024 크기의 원근 그림자 맵으로 초당 10 프레임 이상으로 렌더링되었습니다. 다양한 거리에서의 서로 다른 그림자 디테일에 주목하십시오.

**[그림 10]** 이 생태계의 뷰는 2천만 개 이상의 삼각형을 포함하며, 점과 폴리곤의 혼합으로 1초 안에 렌더링됩니다(왼쪽). 균일 그림자 맵의 그림자를 추가하면 품질이 크게 향상되지만(중앙), 원근 그림자 맵만이 근처의 세밀한 그림자를 캡처합니다(오른쪽). 오른쪽 이미지의 총 렌더링 시간은 1.2초입니다.

---

전체 논문의 완전한 번역을 제공했습니다. 원문의 모든 내용을 누락 없이 번역했습니다.
