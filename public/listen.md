
---

#network #language/c #socket_programming #linux/system_call

*연결 요청 대기 상태로의 진입*

---

[[bind]]의 함수호출을 통해서 소켓에 주소까지 할당했다면, 이번에는 **listen**의 호출을 통해서 **연결 요청 대기 상태**로 진입해야 한다. 그리고 listen 함수가 호출되어야 클라이언트가 연결요청을 할 수 있는 상태가 된다. 즉, listen 함수가 호출되어야 클라이언트는 연결요청을 위해서 connect 함수를 호출할 수 있다(이전에 connect 함수가 호출되면 오류 발생).

```c
#include <sys/socket.h>

int listen(int sock, int backlog);
```

- sock : 연결 요청 대기 상태에 두고자 하는 소켓의 파일 디스크립터 전달, 이 함수의 인자로 전달된 디스크립터의 소켓이 **서버 소켓(리스닝 소켓)**이 된다.
- backlog : **연결 요청 대기 큐(Queue)**의 크기 정보 전달. 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결 요청을  5개까지 대기시킬 수 있다.
- 반환값: 정상적으로 처리에 성공하면 0, 아니면 -1을 반환한다.

#### 연결 요청 대기 상태란?

![[연결 요청 대기 큐.png]]

==그렇다면 연결 요청 대기 상태란 무엇인가?==
클라이언트의 연결 요청도 인터넷을 통해서 흘러 들어오는 일종의 데이터 전송이기 때문에, 이것을 받아들이려면 소켓이 하나 있어야 한다. **서버 소켓**의 역할이 이것이다. 서버 소켓은 클라이언트의 연결 요청을 전담하여 수신한다.
listen 함수가 호출되면 서버 소켓이 만들어지고, listen 함수의 두 번째 인자로 전달되는 정수의 크기에 해당하는 대기실이 만들어진다. 이 대기실을 가리켜 **연결요청 대기 큐**라 한다. 서버 소켓은 클라이언트로부터 받은 연결 요청을 연결요청 대기 큐에 저장한다.
서버 소켓과 연결 요청 대기 큐가 완전히 준비되어서 클라이언트의 연결요청을 받아들일 수 있는 상태를 가리켜 **연결 요청 대기 상태**라 한다.

> listen의 두 번째 인자로 전달될 적절한 인자의 값은 서버의 성격마다 다르지만, 웹 서버와 같이 잦은 연결 요청을 받는 서버의 경우에는 최소 15 이상을 전달해야 한다. 참고로 연결 요청 대기 큐의 크기는 어디까지나 실험적 결과에 의존해서 결정하게 된다.

---

참고자료

#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍

---