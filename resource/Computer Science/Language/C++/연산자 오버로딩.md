
---

#language #cpp 

*operation overloading*

---

#### 개요

연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.

연산자 오버로딩에 사용되는 함수명은 operation + (연산자) 의 형태를 띈다.
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		Point operator+(const Point &ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

```

다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.

`pos1 + pos2;`

이 문장은 아래와 같이 분해할 수 있다.

`pos1`
`+`
`pos2`

연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.

`pos`
`.operator+`
`(pos2)`

`pos.operator+(pos2);`

#### 전역함수에 의한 연산자 오버로딩

연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.

1. 멤버함수에 의한 연산자 오버로딩
2. 전역함수에 의한 연산자 오버로딩

개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.
전역함수를 이용해서 오버로딩을 하면 `pos1 + pos2`는 다음과 같이 해석이 된다.

`operator+(pos1, pos2);`

아래 예제를 참조하자.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &pos1, const Point &pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &pos1, const Point &pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

```

위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.

전역 함수를 이용한 연산자 오버로딩은 후술할 **교환 법칙이 성립하는 연산자 오버로딩**의 구현에 유용하게 사용된다.

#### 오버로딩이 불가능한 연산자의 종류

| .                | 멤버 접근 연산자        |
| ---------------- | ----------------------- |
| .*               | 멤버 포인터 연산자      |
| ::               | 범위 지정 연산자        |
| ?:               | 조건 연산자(3항 연산자) |
| sizeof           | 바이트 단위 크기 계산   |
| typeid           | RTTI 관련 연산자        |
| static_cast      | 형변환 연산자           |
| dynamic_cast     | 형변환 연산자           |
| const_cast       | 형변환 연산자           |
| reinterpret_cast | 형변환 연산자           |

이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.

#### 멤버함수 기반으로만 오버로딩이 가능한 연산자

| =   | 대입 연산자                     |
| --- | ------------------------------- |
| ()  | 함수 호출 연산자                |
| []  | 배열 접근 연산자(인덱스 연산자) |
| ->  | 멤버 접근을 위한 포인터 연산자  |

이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.

#### 연산자 오버로딩에 있어서의 주의사항

1. 연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
2. 연산자의 우선 순위와 결합성은 바뀌지 않는다.
3. 매개변수의 디폴트 값 설정이 불가능하다.
4. 클래스가 아닌 일반 자료형 간의 연산을 재정의 할 수는 없다.
	- 부연 : 예를 들어 'int 형 변수 간의 덧셈'과 같은 동작을 재정의할 수는 없다는 말이다.

#### 단항 연산자의 오버로딩

피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.

대표적인 단항 연산자로는 다음의 두 가지가 있다.

- `++`
- `--`

단항 연산자는 연산 결과가 피연산자 객체 스스로에 적용되기 때문에 함수에 인자를 전달할 필요가 없다.
따라서 다음의 형태를 띈다.

```cpp

//전위 연산을 담당하는 함수의 형태
Obj &operation++() { /* . . . */ }

```

위의 연산자들이 피연산자의 앞에 위치하면 전위 연산자, 뒤에 위치하면 후위 연산자가 된다.
둘을 구분하기 위하여, 후위 연산을 담당하는 함수에게만 키워드 int를 표시한다. int 키워드는 오로지 전위와 후위를 구분하기 위해 존재하며, int 형 인자를 전달하는 것이 아니다.

```cpp

//후위 연산을 담당하는 함수의 형태
Obj &operation++( int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

```

#### 연산자 오버로딩 - 참조자 반환

위 절의 예제에서 `operation++()`은 객체의 참조값을 반환한다. 사실 객체의 멤버 변수를 1 더하는 동작만을 정의한다면 다음과 같이 반환형을 void로 하여도 상관없다.

```cpp

void operation++()
{
	//var1과 var2는 객체의 멤버변수
	var1 += 1;
	var2 += 1;
}

```

그러나 이러한 형식으로 함수를 정의하면 다음과 같은 형태의 연산이 불가능하다.

1. `++(++obj) //obj에 ++연산을 연속적으로 2번 적용하고자 함`
2. operation++은 void를 반환하므로 위 연산은 다음과 동일하다.
	`++(void) //error`

따라서 위와 같은 연산이 가능하게 하기 위해서는 반환형을 객체의 참조자로 하는 것이 좋다.

```cpp
```

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---