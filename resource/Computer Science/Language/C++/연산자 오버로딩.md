
---

#language #cpp 

*operation overloading*

---

#### 개요

연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.

연산자 오버로딩에 사용되는 함수명은 operation + (연산자) 의 형태를 띈다.
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		Point operator+(const Point &ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

```

다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.

`pos1 + pos2;`

이 문장은 아래와 같이 분해할 수 있다.

`pos1`
`+`
`pos2`

연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.

`pos`
`.operator+`
`(pos2)`

`pos.operator+(pos2);`

#### 전역함수에 의한 연산자 오버로딩

연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.

1. 멤버함수에 의한 연산자 오버로딩
2. 전역함수에 의한 연산자 오버로딩

개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.
전역함수를 이용해서 오버로딩을 하면 `pos1 + pos2`는 다음과 같이 해석이 된다.

`operator+(pos1, pos2);`

아래 예제를 참조하자.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &pos1, const Point &pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &pos1, const Point &pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

```

위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.

전역 함수를 이용한 연산자 오버로딩은 후술할 **교환 법칙이 성립하는 연산자 오버로딩**의 구현에 유용하게 사용된다.

#### 오버로딩이 불가능한 연산자의 종류

| .                | 멤버 접근 연산자        |
| ---------------- | ----------------------- |
| .*               | 멤버 포인터 연산자      |
| ::               | 범위 지정 연산자        |
| ?:               | 조건 연산자(3항 연산자) |
| sizeof           | 바이트 단위 크기 계산   |
| typeid           | RTTI 관련 연산자        |
| static_cast      | 형변환 연산자           |
| dynamic_cast     | 형변환 연산자           |
| const_cast       | 형변환 연산자           |
| reinterpret_cast | 형변환 연산자           |

이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.

#### 멤버함수 기반으로만 오버로딩이 가능한 연산자

| =   | 대입 연산자                     |
| --- | ------------------------------- |
| ()  | 함수 호출 연산자                |
| []  | 배열 접근 연산자(인덱스 연산자) |
| ->  | 멤버 접근을 위한 포인터 연산자  |

이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.

#### 연산자 오버로딩에 있어서의 주의사항

1. 연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
2. 연산자의 우선 순위와 결합성은 바뀌지 않는다.
3. 매개변수의 디폴트 값 설정이 불가능하다.
4. 클래스가 아닌 일반 자료형 간의 연산을 재정의 할 수는 없다.
	- 부연 : 예를 들어 'int 형 변수 간의 덧셈'과 같은 동작을 재정의할 수는 없다는 말이다.

#### 단항 연산자의 오버로딩

피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.

대표적인 단항 연산자로는 다음의 두 가지가 있다.

- `++`
- `--`

단항 연산자는 연산 결과가 피연산자 객체 스스로에 적용되기 때문에 함수에 인자를 전달할 필요가 없다.
따라서 멤버함수의 경우, 다음의 형태를 띈다.

```cpp

//전위 연산을 담당하는 함수의 형태
Obj &operation++() { /* . . . */ }

```

위의 연산자들이 피연산자의 앞에 위치하면 전위 연산자, 뒤에 위치하면 후위 연산자가 된다.
둘을 구분하기 위하여, 후위 연산을 담당하는 함수에게만 키워드 int를 표시한다. int 키워드는 오로지 전위와 후위를 구분하기 위해 존재하며, int 형 인자를 전달하는 것이 아니다.

```cpp

//후위 연산을 담당하는 함수의 형태
Obj &operation++( int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

```

마찬가지로 전역함수로 단항 연산을 구현할 경우, 이항 연산과 달리 피연산자를 하나만 전달하면 된다.

```cpp

//전위 연산을 담당하는 함수의 형태
Obj &operation++( Obj &a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
Obj &operation++( Obj &a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

```

#### 연산자 오버로딩 - 참조자 반환을 통한 연속적인 연산의 구현

위 절의 예제에서 `operation++()`은 객체의 참조값을 반환한다. 사실 객체의 멤버 변수를 1 더하는 동작만을 정의한다면 다음과 같이 반환형을 void로 하여도 상관없다.

```cpp

void operation++()
{
	//var1과 var2는 객체의 멤버변수
	var1 += 1;
	var2 += 1;
}

```

그러나 이러한 형식으로 함수를 정의하면 다음과 같은 형태의 연산이 불가능하다.

1. `++(++obj) //obj에 ++연산을 연속적으로 2번 적용하고자 함`
2. operation++은 void를 반환하므로 위 연산은 다음과 동일하다.
	`++(void) //error`

따라서 위와 같은 연산이 가능하게 하기 위해서는 반환형을 객체의 참조자로 하는 것이 좋다.

```cpp

Obj &operation++()
{
	var1 += 1;
	var2 += 1;
	
	return (*this); //객체 스스로의 참조값을 반환
}

```

1. `++(++obj)`를 연산하고자 함.
2.  `operation++`은 객체의 참조값을 반환하므로 위 연산은 다음과 동일하다.
	1. `++(obj.operation++())`
	2. `++(obj 객체의 참조값)`
	3. `(obj 객체의 참조값).operation++()`

#### 연산자 오버로딩 - const 객체 반환을 통한 연속적인 연산의 제한

C++ 언어에서는 다음과 같은 연속적인 후위 연산을 금지하고 있다.

`(obj--)--;`

따라서 다음과 같이 `operation--()`의 반환형을 const 객체로 선언하면 연속적인 후위 연산을 제한할 수 있다.

```cpp

//전위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

```

1. `(obj--)--;`를 연산하고자 함.
2. `operation--`는 const 임시 객체를 반환하므로 위 연산은 다음과 동일하다.
	1. `(obj.operation--())--`
	2. `(Obj 클래스의 const 임시 객체)--`
	3. `(Obj 클래스의 const 임시 객체).operation--() // error : const 임시 객체는 const 멤버 함수가 아닌 operation--()를 호출할 수 없다.`

#### 자료형이 다른 두 피연산자를 대상으로 하는 연산, 연산자의 교환법칙 구현하기

곱셈과 같은 연산은 다음과 같이 피연산자 2개의 자료형이 서로 다를 수 있다.

```cpp

class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = pos * 3;
	cpy = pos * 3 * 2;

	return (0);
}

```

위 예제에서 `cpy = pos * 3;`은 `cpy = 3 * pos;`으로도 표현할 수 있어야 한다.
하지만 `cpy = 3 * pos;`은 다음과 같이 해석될 수는 없기 때문에 연산자 오버로딩이 불가하다.

`3.operator*(pos);`

따라서 * 연산자의 교환법칙을 구현하려면 전역 함수를 사용하여 다음과 같이 정의해야 한다.

```cpp

class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
	friend Point operator*(int n, Point &pos);
}

Point operator*(int n, Point &pos)
{
	return ref * n;
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = 3 * pos; //operator*(3, pos);로 해석됨.
	cpy = 3 * pos * 2; //operator*(3, pos).operator*(3);으로 해석됨.

	return (0);
}

```

#### 대입 연산자

대입 연산자는 [[복사 생성자]]와 매우 유사한 성격을 가지고 있다.

*복사 생성자의 특성*

1. 정의하지 않으면 디폴트 복사 생성자가 삽입된다.
2. 디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
3. 생성자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.

*대입 연산자의 특성*

1. 정의하지 않으면 **디폴트 대입 연산자**가 삽입된다.
2. 디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
3. 연산자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.

그러나 대입 연산자와 복사 생성자는 호출시점에 차이를 갖는다.

- 복사 생성자 : 새로 생성하는 객체의 초기화에 기존에 생성된 객체가 사용.
- 대입 연산자 : 기존의 생성된 

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---