
---

#language #cpp 

*operation overloading*

---

#### 개요

연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.

연산자 오버로딩에 사용되는 함수명은 operation + (연산자) 의 형태를 띈다.
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		Point operator+(const Point &ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

```

다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.

`pos1 + pos2;`

이 문장은 아래와 같이 분해할 수 있다.

`pos1`
`+`
`pos2`

연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.

`pos`
`.operator+`
`(pos2)`

`pos.operator+(pos2);`

#### 전역함수에 의한 연산자 오버로딩

연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.

1. 멤버함수에 의한 연산자 오버로딩
2. 전역함수에 의한 연산자 오버로딩

개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.
전역함수를 이용해서 오버로딩을 하면 `pos1 + pos2`는 다음과 같이 해석이 된다.

`operator+(pos1, pos2);`

아래 예제를 참조하자.

```cpp

#include <iostream>
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout<<'['<<xpos<<", "<<ypos<<']'<<endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &pos1, const Point &pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &pos1, const Point &pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

```

위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.

전역 함수를 이용한 연산자 오버로딩은 후술할 **교환 법칙이 성립하는 연산자 오버로딩**의 구현에 유용하게 사용된다.

#### 오버로딩이 불가능한 연산자의 종류

| .                | 멤버 접근 연산자        |
| ---------------- | ----------------------- |
| .*               | 멤버 포인터 연산자      |
| ::               | 범위 지정 연산자        |
| ?:               | 조건 연산자(3항 연산자) |
| sizeof           | 바이트 단위 크기 계산   |
| typeid           | RTTI 관련 연산자        |
| static_cast      | 형변환 연산자           |
| dynamic_cast     | 형변환 연산자           |
| const_cast       | 형변환 연산자           |
| reinterpret_cast | 형변환 연산자           |

이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.

#### 멤버함수 기반으로만 오버로딩이 가능한 연산자

| =   | 대입 연산자                     |
| --- | ------------------------------- |
| ()  | 함수 호출 연산자                |
| []  | 배열 접근 연산자(인덱스 연산자) |
| ->  | 멤버 접근을 위한 포인터 연산자  |

이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.

#### 연산자 오버로딩에 있어서의 주의사항

1. 연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
2. 연산자의 우선 순위와 결합성은 바뀌지  않는다.

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---