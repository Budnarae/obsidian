
---

#language #cpp 

*type-casting*

---

#### 개요

c++에서는 c 스타일의 형 변환 연산자를 가리켜 '오래된 C 스타일 형 변환 연산자(Old C-style cast operator)'라 부르기도 한다. 이렇듯 c 스타일의 형 변환 연산자는 c 언어와의 호환성을 위해서 존재할 뿐, c++에서는 새로운 형 변환 연산자와 규칙을 제공하고 있다.

c 스타일의 형 변환 연산자는 그 기능이 강력해서, 아래와 같이 형 변환이 일어나면 안 되는 케이스에서도 형변환이 일어날 수 있다.

```cpp

class Car
{
	//생략
};

class Truck : public Car
{
	//생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	Truck *ptruck1 = (Truck *)pcar1; //문제 없어 보이는 형 변환
	
	Car *pcar2 = new Car(120);
	Truck *ptruck2 = (Truck *)pcar2; //문제가 바로 보이는 형 변환
}

```

기초 클래스의 포인터 형을 유도 클래스의 포인터 형으로 형 변환하는 것은 일반적인 경우의 형 변환이 아님에도 불구하고, 형 변환 연산자의 기능이 너무 강력하여 형 변환이 이루어지는 모습이다.

이러한 문제점 때문에 c++ 에서는 다음과 같이 4개의 연산자를 추가로 제공하면서 용도에 맞는 형 변환 연산자의 사용을 유도하고 있다.

- dynamic_cast
- static_cast
- const_cast
- reinterpret_cast

---

#### dynamic_cast : 상속관계에서의 안전한 형 변환

dynamic_cast 형 변환 연산자는 다음의 형태를 갖는다.

```cpp

dynamic_cast<T>(expr)

```

dynamic_cast는 다음의 조건을 충족하여야 정상적으로 컴파일되며, 그렇지 않으면 컴파일 에러가 발생한다.

1. <> 사이에 변환하고자 하는 자료형의 이름을 둔다. 자료형은 객체의 포인터 또는 참조형이여야 한다.
2. () 사이에는 변환의 대상이 와야 한다.
3. 상속 관계에 놓여 있는 두 클래스 사이에서 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환하는 경우여야 한다.

종합적으로 dynamic_cast는 다음을 의미한다.

*상속 관계에 있는 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환하겠습니다.*

```cpp

/*DynamicCasting.cpp*/

#include <iostream>
using namespace std;

class Car
{
	// 생략
};

class Truck
{
	// 생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	//Truck *ptruck1 = dynamic_cast<Truck *>(pcar1); -> 에러, 그러나 경우에 따라선 필요한 형 변환이므로 그러한 경우 static_cast를 사용

	Car *pcar2 = new Car(120);
	//Truck *ptruck2 = dynamic_cast<Truck *>(pcar2); -> 에러

	Truck *ptruck3 = new Truck(70, 150);
	Car *pcar3 = dynamic_cast<Car *>(ptruck3); //컴파일 OK!
}

```

#### static_cast: A 타입에서 B 타입으로

```cpp

static_cast<T>(expr)

```

dynamic_cast가 자식 -> 부모로의 형 변환만 허용하는데 반하여 static_cast는 보다 넓은 범위의 형변환을 허용한다.

1. 자식 -> 부모로의 형 변환뿐만이 아닌, 부모 -> 자식으로의 형변환 또한 허용한다.
2. 기본 자료형(여기서 기본 자료형이라함은 포인터 자료형을 제외한 것을 말한다) 데이터 간의 형 변환에도 사용이 된다.

따라서 부모 -> 자식으로의 캐스팅 같은 잘못된 형 변환을 할 수 있으므로 이에 대하여 개발자는 보다 신중하게 사용하여야 한다.

```cpp

/*StaticCasting.cpp*/

#include <iostream>
using namespace std;

class Car
{
	// 생략
};

class Truck
{
	// 생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	Truck *ptruck1 = static_cast<Truck *>(pcar1); // 허용

	Car *pcar2 = new Car(120);
	Truck *ptruck2 = dynamic_cast<Truck *>(pcar2); // 허용 -> 그러나 문제가 발생할 수 있는 코드

	Truck *ptruck3 = new Truck(70, 150);
	Car *pcar3 = dynamic_cast<Car *>(ptruck3); //컴파일 OK!
}

```

- static_cast가 dynamic_cast 보다 빠르기 때문에 dynamic_cast를 사용해도 되는 상황에 static_cast를 사용하는 경우도 있다.

#### const_static : const 성향 삭제

C++에서는 포인터와 참조자의 const 성향을 제거하는 형 변환을 목적으로, 다음의 형 변환 연산자를 제공한다.

```cpp

const_cast<T>(expr)

```

```cpp

/*ConstCasting.cpp*/

#include <iostream>
using namespace std;

void ShowString(char *str)
{
	cout<<str<<endl;
}

void ShowAddResult(int &n1, int &n2)
{
	cout<<(n1 + n2)<<endl;
}

int main(void)
{
	const char *name = "Lee Sung Ju";
	ShowString(const_cast<char *>(name));
	
	const int &num1 = 100;
	const int &num2 = 200;
	ShowAddResult(const_cast<int &>(num1), const_cast<int &>(num2));
	
	return (0);
}

```

위 예제에서와 같이 const_cast 형 변환 연산은, 함수의 인자전달 시 const 선언으로 인한 형(type)의 불일치가 발생해서 인자의 전달이 불가능한 경우에 유용하게 사용이 된다.

- const_cast 연산자는 volatile 특성을 제거하는 데에도 사용할 수 있다.

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---