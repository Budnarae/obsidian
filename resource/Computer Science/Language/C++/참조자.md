
---

#language #cpp 

*reference*

---

변수명은 할당된 메모리 공간에 이름을 붙이는 것과 같다. 참조자는 이미 변수명이 붙어있는 메모리 공간이 제 2의 별칭을 붙이는 것과 같다. 변수명을 통해 메모리 공간의 데이터를 조작할 수 있는 것과 마찬가지로, 참조자를 통해서도 메모리 공간의 데이터를 조작할 수 있다.

참조자는 아래와 같이 선언될 수 있다.

~~~cpp

#include <iostream>

using namespace std;

int main(void)
{
	int num1=1020;
	int &num2=num1;

	num2=3047;
	cout<<"VAL: "<<num1<<endl;
	cout<<"REF: "<<num2<<endl;

	cout<<"VAL: "<<&num1<<endl;
	cout<<"REF: "<<&num2<<endl;
}

~~~

그리고 참조자는 아래와 같은 특징을 가진다.

1. 참조자의 수에는 제한이 없다.

~~~cpp

int num1=2749;
int &num2=num1;
int &num3=num1;
int &num4=num1;

~~~

2. 참조자를 대상으로 참조자를 선언하는 것도 가능하다.

~~~cpp

int1=2759;
int &num2=num1;
int &num3=num2;
int &num4=num3;

~~~

3. 참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누군가를 참조해야만 한다. 즉, 다음과 같은 선언은 유효하지 않다.

~~~cpp

int &ref=20; //error

~~~

4. 참조자를 미리 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 참조의 대상을 바꾸는 것도 불가능하다.

~~~cpp

int &ref; //error

~~~

5. 참조자를 선언하면서 NULL로 초기화하는 것도 불가능하다.

~~~cpp

int &ref=NULL; //error

~~~

6. **참조자를 사용하면 Call-by-reference의 방식으로 변수를 조작할 수 있다.**

~~~cpp

#include <iostream>

using namespace std;

void SwapByRef2(int &ref1, int &ref2)
{
	int temp=ref1;
	ref1=ref2;
	ref2=temp;
}

int main(void)
{
	int val1=10;
	int val2=20;

	SwapByRef2(val1, val2);

	cout<<"val1: "<<val1<<endl;
	cout<<"val2: "<<val2<<endl;

	return 0;
}

~~~

7. 참조자는 반환형으로도 사용될 수 있으며, 보통 참조자의 초기화에 함수의 반환을 사용할 때 사용된다.

~~~cpp

//RefReturnOne.cpp
#include <iostream>

using namespace std;

//참조자에서 사용된 지역변수는 함수의 반환과 함께 소멸된다.
//하지만 참조사가 소멸된다고 해서 참조자가 참조하던 변수가 소멸하지는 않는다.
int& RefRetFuncOne(int &ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int &num2=RefRetFuncOne(num1);

	num1++;
	num2++;
	cout<<"num1: "<<num1<<endl;
	cout<<"num2: "<<num2<<endl;  

	return 0;
}

//RefReturnTwo.cpp
//참조자 반환을 일반 자료형으로 받는 것 또한 가능하다.
#include <iostream>

using namespace std;

int& RefRetFuncOne(int &ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int num2=RefRetFuncOne(num1);

	num1+=1;
	num2+=100;
	cout<<"num1: "<<num1<<endl;
	cout<<"num2: "<<num2<<endl;
	
	return 0;
}

//RefReturnThree.cpp
//함수가 인자를 참조형으로 받지만 반환은 일반형으로 하는 경우
#include <iostream>

using namespace std;

int RefRetFuncTwo(int &ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int num2=RefRetFuncTwo(num1);

	num1+=1;
	num2+=100;
	cout<<"num1: "<<num1<<endl;
	cout<<"num2: "<<num2<<endl;

	return 0;
}

~~~

c++은 참조자를 사용하여 Call-by-reference를 할 수 있으므로 개발자는 코드리뷰를 할 때 함수 외부에 변수가 변경되는지 아닌지를 확인해야 하는 불편함이 있다.
따라서, 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 하

~~~cpp

//const -> 함수 HappyFunc 내에서 참조자 ref를 이용한 값의 변경을 하지 않음을 명시
void HappyFunc(const int &ref) { . . . . } 

~~~

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---