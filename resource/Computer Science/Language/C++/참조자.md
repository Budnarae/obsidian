
---

#language #cpp 

*reference*

---

변수명은 할당된 메모리 공간에 이름을 붙이는 것과 같다. 참조자는 이미 변수명이 붙어있는 메모리 공간이 제 2의 별칭을 붙이는 것과 같다. 변수명을 통해 메모리 공간의 데이터를 조작할 수 있는 것과 마찬가지로, 참조자를 통해서도 메모리 공간의 데이터를 조작할 수 있다.

참조자는 아래와 같이 선언될 수 있다.

~~~cpp

#include <iostream>

using namespace std;

int main(void)
{
	int num1=1020;
	int &num2=num1;

	num2=3047;
	cout<<"VAL: "<<num1<<endl;
	cout<<"REF: "<<num2<<endl;

	cout<<"VAL: "<<&num1<<endl;
	cout<<"REF: "<<&num2<<endl;
}

~~~

그리고 참조자는 아래와 같은 특징을 가진다.

1. 참조자의 수에는 제한이 없다.

~~~cpp

int num1=2749;
int &num2=num1;
int &num3=num1;
int &num4=num1;

~~~

2. 참조자를 대상으로 참조자를 선언하는 것도 가능하다.

~~~cpp

int1=2759;
int &num2=num1;
int &num3=num2;
int &num4=num3;

~~~

3. 참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누군가를 참조해야만 한다. 즉, 다음과 같은 선언은 유효하지 않다.

~~~cpp

int &ref=20; //error

~~~

4. 참조자를 미리 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 참조의 대상을 바꾸는 것도 불가능하다.

~~~cpp

int &ref; //error

~~~

5. 참조자를 선언하면서 NULL로 초기화하는 것도 불가능하다.

~~~cpp

int &ref=NULL; //error

~~~

6. **참조자를 사용하면 Call-by-reference의 방식으로 변수를 조작할 수 있다.**

~~~cpp

#include <iostream>

using namespace std;

void SwapByRef2(int &ref1, int &ref2)
{
	int temp=ref1;
	ref1=ref2;
	ref2=temp;
}

int main(void)
{
	int val1=10;
	int val2=20;

	SwapByRef2(val1, val2);

	cout<<"val1: "<<val1<<endl;
	cout<<"val2: "<<val2<<endl;

	return 0;
}

~~~

7. 참조자는 반환형으로도 사용될 수 있으며, 보통 참조자의 초기화에 함수의 반환을 사용할 때 사용된다.

~~~cpp

#include <iostream>

using namespace std;

  

int& RefRetFuncOne(int &ref)

{

ref++;

return ref;

}

  

int main(void)

{

int num1=1;

int &num2=RefRetFuncOne(num1);

  

num1++;

num2++;

cout<<"num1: "<<num1<<endl;

cout<<"num2: "<<num2<<endl;

  

return 0;

}

~~~

c++은 참조자를 사용하여 Call-by-reference를 할 수 있으므로 개발자는 코드리뷰를 할 때 함수 외부에 변수가 변경되는지 아닌지를 확인해야 하는 불편함이 있다. 만약 참조자를 통해 변수를 변경하지 않을 경우, const 키워드를 사용하여 이를 명시하는 것이 코드 가독성에 도움이 된다.

~~~cpp

//const -> 함수 HappyFunc 내에서 참조자 ref를 이용한 값의 변경을 하지 않음을 명시
void HappyFunc(const int &ref) { . . . . } 

~~~

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---