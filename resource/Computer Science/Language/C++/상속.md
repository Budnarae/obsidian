
---

#language #cpp 

*inheritance*

---

클래스가 다른 클래스에게 자신이 가지고 있는 멤버들을 물려주는 것을 **상속**이라고 한다.

상속을 하는 쪽과 상속을 받는 쪽을 각각 다음의 용어들로 정의한다.

| 상속 하는 쪽       | 상속 받는 쪽         |
| ------------------ | -------------------- |
| 상위 클래스        | 하위 클래스          |
| 기초(base) 클래스  | 유도(derived) 클래스 |
| 슈퍼(super) 클래스 | 서브(sub) 클래스     |
| 부모 클래스        | 자식 클래스          |

예를 들러, UnivStudent 클래스가 Student 클래스를 상속받을 때, 다음과 같은 형식으로 상속받는다.

```cpp

#ifndef US_HPP
#define US_HPP

#include <iostream>
#include <cstring>

using namespace std;

//부모 클래스
class Person
{
	private :
		int age;
		char name[50];
	public :
		Person(int myage, char *myname);
		void WhatYourName() const;
		void HowOldAreYou() const;
};

//자식 클래스
class UnivStudent : public Person //UnivStudent가 Person을 'public' 상속함
{
	//부모 클래스로부터 물려받은 멤버에 더해 자신만의 독자적인 멤버를 추가로 선언한다.
	private :
		char major[50]; //전공과목
	public :
		UnivStudent(char *myname, int myage, char *mymajor);
		void WhoAreYou() const;
};

#endif

```

상속은 다음과 같은 특성을 갖는다.

1. [[접근제어 지시자]]의 **접근제한 기준은 객체가 아닌 클래스이기 때문에** 부모 클래스에서 private으로 선언한 멤버는 자식 클래스에서 접근이 불가능하다.
	- 따라서 자식 클래스에서 부모 클래스의 private멤버에 접근하기 위해서는 부모 클래스로부터 상속받은 public 함수를 사용하는 우회적인 방법을 사용해야 한다.
	- 이렇듯 **정보의 은닉**은 하나의 객체 안에서도 진행이 된다.

2. 자식 클래스는 자신의 멤버 뿐만이 아니라 상속받은 멤버도 초기화하여야 한다.
	- 이를 위하여 생성자를 호출할 때 [[멤버 이니셜라이저 | 이니셜라이저]]를 사용하여 부모의 생성자를 호출한다.
	- 만약 부모의 생성자를 호출하지 않는 경우, 부모의 생성자 중 매개변수가 void인 생성자를 자동으로 호출한다 ( 없을 경우 error ).

```cpp

// 부모 클래스의 생성자
Person::Person(int myage, char *myname) : age(myage)
{
	strcpy(name, myname);
}

// 자식 클래스의 생성자
UnivStudent::UnivStudent(char *myname, int myage, char *mymajor) : Person(myage, myname) // -> 이니셜라이저를 사용하여 부모의 생ㅅ
{
	strcpy(major, mymajor);
}

```

---

참고자료

[윤성우의 열혈 c++ 프로그래밍](https://product.kyobobook.co.kr/detail/S000001589147)

---