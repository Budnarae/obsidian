
---

#network #c #socket_programming #linux

*스트림의 절반만 닫는다*

---

파일 및 표준 입출력, 그리고 현재 다루고 있는 네트워크 프로그램밍에서 흔히 등장하는 개념인 **스트림**은 **물의 흐름**을 의미한다. 그런데 물의 흐름은 한쪽 방향으로만 형성된다. 마찬가지로 소켓의 스트림 역시 한쪽 방향으로만 데이터의 이동이 가능하기 때문에 양방향 통신을 위해서는 다음 그림에서 보이듯이 두 개의 스트림이 필요하다.

![[소켓을 기반으로 생성되는 두 개의 스트림.png | 600]]

*한 소켓의 입력 스트림은 맞은편  소켓의 출력 스트림으로 이어진다.*

이번 문서에서 다루는 **Half-close**는 한 번에 두 개의 스트림을 모두 끊어버리는 게 아닌, 이 중 하나의 스트림만 끊는 것이다. 리눅스의 close()는 두 스트림을 동시에 끊어버리기 때문에 [[shutdown]]이라는 별도의 시스템콜을 사용해야 한다.

### Half-close가 필요한 이유

#### 일방적인 연결 종료의 문제점

![[일방적 연결종료.png]]

**close**를 사용하면 출력 버퍼에 남아있는 데이터는 모두 전송하지만, 입력 버퍼를 사용해서는 어떠한 데이터도 수신할 수 없게 된다. 따라서 일방적으로 close를 사용하면 상대가 송신한 데이터를 수신하지 못하고 연결을 종료하는 경우가 발생하게 된다.

이와 같은 문제의 해결을 위해 사용되는 방법은 보통 다음과 같다.

1. 특정 문자를 통신 종료의 신호로 삼아 해당 문자를 수신하기 전에는 close하지 않는다.
2. 충분히 여유를 종료한다.

하지만 위의 방법은 근본적으로 문제를 해결할 수 없다. 1의 경우 텍스트만을 주고 받는 간단한 케이스의 경우 텍스트를 작성하는 사람이 해당 규칙을 인지하고 있으므로 어느정도 유효하지만, 파일 송수신을 하는 경우 해당 파일에 종료를 의미하는 문자가 포함되어 있을 수 있어 중간에 연결이 갑작스럽게 끊길 수 있다.

두번째 방법의 경우, 어느 정도의 시간만큼 대기해야 안전하게 종료할 수 있는지에 대한 기준이 불명확하다.

이러한 문제의 해결을 위해서 데이터의 송수신에 사용되는 **데이터의 일부만 종료(Half-close)**하는 방법이 제공되는 것이다.

#### eof를 사용한 연결 제어



---

참고자료

#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍

---