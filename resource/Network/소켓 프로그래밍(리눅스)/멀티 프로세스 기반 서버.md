
---

#socket_programming #network #server 

*multi process server*

---

멀티 프로세스 기반 서버는 다음과 같은 과정을 통해 non-blocking한(즉, [[다중 접속 서버]]를) 구현한다.

1. 서버(부모 프로세스)는 accept 함수 호출을 통해서 연결 요청을 수락한다.
2. 이때 얻게 되는 소켓의 파일 디스크립터를 자식 프로세스를 생성해서 넘겨준다.
3. 자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.
4. 부모 프로세스는 1의 과정을 되풀이하며 지속적으로 클라이언트의 연결 요청을 수락한다. 이후 반복.

```c

// echo_mpserv.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <sys/socket.h>

#define BUF_SIZE 30

void error_handling(char *message);
void read_childproc(int sig);

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage : %s <port>\n", argv[0]);
		exit(1);
	}
	
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;

	pid_t pid;
	struct sigaction act;
	socklen_t adr_sz;
	int str_len, state;
	char buf[BUF_SIZE];

	// SIGCHLD가 발생하면 좀비를 회수하도록 처리한다.
	act.sa_handler = read_childproc;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	state = sigaction(SIGCHLD, &act, 0);

	// tcp 서버 소켓을 만든다.
	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_adr.sin_port = htons(atoi(argv[1]));
	
	if (bind(serv_sock, (struct sockaddr *)&serv_adr, sizeof(serv_adr)) == -1)
		error_handling("bind() error");
	if (listen(serv_sock, 5) == -1)
		error_handling("listen() error");

	while (1)
	{
		// 클라이언트의 연결 요청을 수락한다.
		adr_sz = sizeof(clnt_adr);
		clnt_sock = accept(serv_sock, (struct sockaddr *)&clnt_adr, &adr_sz);
		if (clnt_sock == -1)
			continue ;
		else
			puts("new client connected...");

		// fork()하여 자식 프로세스에게 클라이언트에게 서비스 제공하는 작업을 전담한다.
		// 이때, 자식 프로세스는 부모 프로세스의 메모리 공간을 복사하여 생성되므로 별도의 전달 작업
		// 없이 클라이언트와 연결된 소켓을 사용할 수 있다.
		pid = fork();
		if (pid == -1)
		{
			close(clnt_sock);
			continue;
		}
		if (pid == 0)
		{
			close(serv_sock);
			while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0)
				write(clnt_sock, buf, str_len);

			close(clnt_sock);
			puts("client disconnected...");

			return (0);
		}
		else
			close(clnt_sock);
	}
	close(serv_sock);
	return (0);
}

void read_childproc(int sig)
{
	sig = 0;
	
	pid_t pid;
	int status;
	pid = waitpid(-1, &status, WNOHANG);
	printf("removed proc id: %d \n", pid);
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

```

# TCP의 입출력 루틴(Routine) 분할

멀티 프로세스 기반으로 서버를 작성하면 기능 별로 코드를 분할하기 용이하다. 특히 데이터를 송신하는 부분과 데이터를 수신하는 부분을 분할하여 작성하면 코드의 가독성이 크게 증대된다.



---

참고자료

#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍 

---